<!doctype html> <html lang=en > <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <link rel=stylesheet  href="/data-parallelism/previews/PR33/libs/highlight/github.min.css"> <link rel=stylesheet  href="/data-parallelism/previews/PR33/css/franklin.css"> <link rel=stylesheet  href="/data-parallelism/previews/PR33/css/basic.css"> <link rel=icon  href="/data-parallelism/previews/PR33/assets/juliafolds-logo.ico"> <title>Frequently asked questions</title> <header> <div class=blog-name ><a href="/data-parallelism/previews/PR33/">Data-parallel Julia</a></div> <nav> <!-- <ul> <li><a href="/data-parallelism/previews/PR33/">Home</a> <li><a href="/data-parallelism/previews/PR33/menu1/">Code blocks</a> <li><a href="/data-parallelism/previews/PR33/menu2/">More goodies</a> <li><a href="/data-parallelism/previews/PR33/menu3/">Tags</a> </ul> --> <a href="https://github.com/JuliaFolds/data-parallelism/blob/master/src/howto/faq.md"> <img class=github-edit-small  src="https://img.shields.io/badge/-Edit-green?logo=github&style=social"> <img class=github-edit-big  src="https://img.shields.io/badge/source-Suggest%20Edit-green?logo=github&style=social"> </a> <!-- <img src="/data-parallelism/previews/PR33/assets/hamburger.svg" id=menu-icon > --> </nav> </header> <div class=franklin-content ><h1 id=frequently_asked_questions ><a href="#frequently_asked_questions">Frequently asked questions</a></h1> <a id=set-nthreads-at-run-time  class=anchor ></a> <h2 id=can_i_change_the_number_of_execution_threads_without_restarting_julia ><a href="#can_i_change_the_number_of_execution_threads_without_restarting_julia">Can I change the number of execution threads without restarting <code>julia</code>?</a></h2> <p>The number of execution threads is specified at the time <code>julia</code> is started &#40;by command line option <code>-t</code>/<code>--threads</code> or <code>JULIA_NUM_THREADS</code> environment variable&#41;. Thus, to benchmark a generic Julia program with a different number of threads, you would need to start a new <code>julia</code> process each time.</p> <p>Some libraries such as Transducers.jl, FLoops.jl, ThreadsX.jl, and Parallelism.jl support <code>basesize</code> option &#40;see, e.g., <a href="https://juliafolds.github.io/Transducers.jl/dev/reference/manual/#Transducers.foldxt"><code>Transducers.foldxt</code></a>&#41;. It is used for specifying the size of the chunk of input collection processed by one task. Thus, to simulate running code with <code>N</code> threads, you can pass</p> <pre><code class="julia hljs">basesize = length(input_collection) ÷ N</code></pre>
<p>to run a multi-threaded function &#40;provided that <code>N ≤
Threads.nthreads&#40;&#41;</code> and there is no other function spawning tasks&#41;. For example:</p>
<pre><code class="julia-repl hljs"><span class=hljs-meta >julia&gt;</span><span class=julia > <span class=hljs-keyword >using</span> ThreadsX, BenchmarkTools
</span>
<span class=hljs-meta >julia&gt;</span><span class=julia > sum_nthreads(f, xs, N) = ThreadsX.sum(f, xs; basesize = length(xs) ÷ N);
</span>
<span class=hljs-meta >julia&gt;</span><span class=julia > <span class=hljs-meta >@btime</span> sum_nthreads(sin, <span class=hljs-number >1</span>:<span class=hljs-number >1_000_000</span>, <span class=hljs-number >1</span>);
</span>  16.570 ms (5 allocations: 336 bytes)

<span class=hljs-meta >julia&gt;</span><span class=julia > <span class=hljs-meta >@btime</span> sum_nthreads(sin, <span class=hljs-number >1</span>:<span class=hljs-number >1_000_000</span>, <span class=hljs-number >2</span>);
</span>  8.318 ms (46 allocations: 2.56 KiB)

<span class=hljs-meta >julia&gt;</span><span class=julia > <span class=hljs-meta >@btime</span> sum_nthreads(sin, <span class=hljs-number >1</span>:<span class=hljs-number >1_000_000</span>, <span class=hljs-number >4</span>);
</span>  4.403 ms (128 allocations: 7.03 KiB)</code></pre>
<p>Note that this trick cannot be used for experimenting the effect of the number of threads to the load-balancing of multi-threaded code since load-balancing requires starting more than <code>Threads.nthreads&#40;&#41;</code> tasks.</p>
<a id=multi-threading-vs-multi-processing  class=anchor ></a>
<h2 id=should_i_use_multi-threading_or_should_i_use_multi-processing ><a href="#should_i_use_multi-threading_or_should_i_use_multi-processing">Should I use multi-threading? Or should I use multi-processing?</a></h2>
<p>Julia supports <a href="https://docs.julialang.org/en/v1/manual/multi-threading/">threading-based</a> &#40;via <code>Base.Threads</code>&#41; and <a href="https://docs.julialang.org/en/v1/manual/distributed-computing/">process-based</a> &#40;via <a href="https://docs.julialang.org/en/v1/stdlib/Distributed/">Distributed.jl</a>&#41; parallelism paradigms.  Each paradigm has pros and cons.  Choosing the best option requires understanding what your program does.</p>
<p>Multi-threading is better for processing complex and large objects whose serialization become bottleneck in multi-processing -based parallelism.  Note that <a href="https://github.com/JuliaParallel/DistributedArrays.jl">DistributedArrays.jl</a> can be used to reduce serialization overhead in multi-processing.</p>
<p>If your code allocates many intermediate objects, multi-processing -based frameworks such as <a href="https://docs.julialang.org/en/v1/stdlib/Distributed/">Distributed.jl</a> standard library, <a href="https://github.com/JuliaParallel/Dagger.jl">Dagger.jl</a>, or MPI.jl are better option. This is because <code>julia</code>&#39;s memory management system &#40;garbage collection; GC&#41; can be a bottleneck for scaling such type of code to many execution threads.</p>
<p>To make it easy to balance with these trade-offs, it is recommended to use a high-level of abstraction such as data parallelism that helps you switch underlying execution mechanisms. For example JuliaFolds packages such as <a href="https://github.com/JuliaFolds/Folds.jl">Folds.jl</a>, <a href="https://github.com/JuliaFolds/FLoops.jl">FLoops.jl</a>, and <a href="https://github.com/JuliaFolds/Transducers.jl">Transducers.jl</a> have <em>executor</em> argument to easily switch thread-based and process-based execution mechanisms.</p>
<p></p>
<h2 id=why_is_the_approach_using_statethreadid_not_mentioned ><a href="#why_is_the_approach_using_statethreadid_not_mentioned">Why is the approach using <code>state&#91;threadid&#40;&#41;&#93;</code> not mentioned?</a></h2>
<p>See: <a href="https://juliafolds.github.io/FLoops.jl/dev/explanation/faq/#faq-state-threadid">What is the difference of <code>@reduce</code> and <code>@init</code> to the approach using <code>state&#91;threadid&#40;&#41;&#93;</code>? · FAQ · FLoops</a></p>
<div style="float: right">
  <small>
  <a href="?test=show" id=show-test-result >#show test results</a>
  </small>
</div>
<div class=page-foot >
  <div class=copyright >
    <a rel=license  href="http://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png" /></a><br />This work is licensed under a <a rel=license  href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a>.
  </div>
  <div class=copyright >
    &copy; Takafumi Arakaki. Last modified: March 15, 2021. Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia programming language</a>.
  </div>
</div>
</div>
    
    
        


    
    <script>
      (function() {
        if (window.location.search.includes("?test=show")){
          var list = document.getElementsByClassName("test");
          for (let item of list) {
            item.style.display = "block";
          };
        }
      })()
    </script>